# Vole, chapter 3
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#
gap> START_TEST("vole03.tst");

# doc/_Chapter_tut.xml:102-117
gap> LoadPackage("vole", false);;
gap> s := [1,2,3,4,5,6];
[ 1, 2, 3, 4, 5, 6 ]
gap> t := [2,4,6,8,10,12];
[ 2, 4, 6, 8, 10, 12 ]
gap> u := [3,6,9,12,15,18];
[ 3, 6, 9, 12, 15, 18 ]
gap> M12 := MathieuGroup(12);;
gap> Vole.CanonicalImage(M12, s, OnSets);
[ 2, 6, 8, 9, 11, 12 ]
gap> Vole.CanonicalImage(M12, t, OnSets);
[ 2, 6, 8, 9, 11, 12 ]
gap> Vole.CanonicalImage(M12, u, OnSets);
[ 2, 3, 4, 5, 15, 18 ]

# doc/_Chapter_tut.xml:125-136
gap> ps := Vole.CanonicalImagePerm(M12, s, OnSets);
(1,6,9,5,2,12)(3,8,4,11,10,7)
gap> pt := Vole.CanonicalImagePerm(M12, t, OnSets);
(1,3,4,12,2,6,11,7)(9,10)
gap> OnSets(s, ps); # Gives the canonical image from earlier
[ 2, 6, 8, 9, 11, 12 ]
gap> OnSets(s, ps*(pt^-1)); # Gives t
[ 2, 4, 6, 8, 10, 12 ]
gap> ps*(pt^-1) in M12;
true

# doc/_Chapter_tut.xml:144-151
gap> Vole.CanonicalImage(M12, [[1,2,3,4],[4,5,6,7]], OnSetsSets);
[ [ 2, 3, 7, 12 ], [ 3, 6, 10, 11 ] ]
gap> Vole.CanonicalImage(M12, [[1,2,3,4],[4,5,6,7]], OnSetsTuples);
[ [ 2, 8, 3, 6 ], [ 6, 4, 10, 5 ] ]
gap> Vole.CanonicalImage(M12, DigraphCycle(12), OnDigraphs);
<immutable digraph with 12 vertices, 12 edges>

# doc/_Chapter_tut.xml:178-183
gap> M12 := MathieuGroup(12);;
gap> S := [ 1, 2, 4, 5 ];;
gap> G := Group([(1,8,7,2,3,10,9,4)(5,6,11,12), (3,11)(4,12,6,8,10)]);;
gap> H := Group([(1,2,3,4,9,10,5,6,11,8)(7,12), (1,5,9)(6,12)(8,10)]);;

# doc/_Chapter_tut.xml:193-199
gap> answer := Group([(1,2)(3,10)(4,5)(6,7)(8,9)(11,12),
>                     (2,4)(3,7)(8,12)(9,11)]);
Group([ (1,2)(3,10)(4,5)(6,7)(8,9)(11,12), (2,4)(3,7)(8,12)(9,11) ])
gap> StructureDescription(answer);
"D8"

# doc/_Chapter_tut.xml:211-216
gap> Intersection(Stabiliser(M12, S, OnSets),
>                 Normaliser(G, H))
> = answer;
true

# doc/_Chapter_tut.xml:224-229
gap> M12andG := Intersection(M12, G);;
gap> stab := Stabiliser(M12andG, S, OnSets);;
gap> Normaliser(stab, H) = answer;
true

# doc/_Chapter_tut.xml:236-241
gap> M12andG := Intersection(M12, G);;
gap> norm := Normaliser(M12andG, H);;
gap> Stabiliser(norm, S, OnSets) = answer;
true

# doc/_Chapter_tut.xml:251-256
gap> stab := Vole.Stabiliser(M12, S, OnSets);;
gap> norm := Vole.Normaliser(G, H);;
gap> answer = Vole.Intersection(stab, norm);
true

# doc/_Chapter_tut.xml:315-322
gap> VoleFind.Group(Constraint.InGroup(M12),
>                   Constraint.Stabilize(S, OnSets),
>                   Constraint.InGroup(G),
>                   Constraint.Normalize(H))
> = answer;
true

# doc/_Chapter_tut.xml:342-356
gap> VoleFind.Group(Constraint.InGroup(M12),
>                   Constraint.Stabilize(S, OnSets),
>                   Constraint.InGroup(G),
>                   GB_Con.NormaliserSimple(H))
> = answer;
true
gap> VoleFind.Group(Constraint.InGroup(M12),
>                   Constraint.Stabilize(S, OnSets),
>                   Constraint.InGroup(G),
>                   Constraint.Normalise(H),
>                   GB_Con.NormaliserSimple(H))
> = answer;
true

#
gap> STOP_TEST("vole03.tst", 1);
